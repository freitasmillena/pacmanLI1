<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Tarefa3</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Maria Pinheiro &lt;mcardosorp@gmail.com&gt;;<br />Millena Santos &lt;freitasmillena27@gmail.com&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Tarefa3</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Um m&#243;dulo Haskell que compacta o labirinto com o objetivo de codificar o labirinto para como uma sequ&#234;ncia de instru&#231;&#245;es que, quando executadas, produzem o mesmo labirinto. </p><h1>Introdu&#231;&#227;o</h1><p>A tarefa 3 &#233; respons&#225;vel por facilitar a leitura de um labirinto. Isto &#233;, considerando um labirinto v&#225;lido, o objetivo desta tarefa &#233; convert&#234;-lo numa sequ&#234;ncia de instru&#231;&#245;es de modo a deixar o labirinto num formato mais compacto.</p><h1>Objetivo </h1><p>O nosso objetivo nesta tarefa era criar uma fun&#231;&#227;o que conseguisse converter o labirinto de forma a que o n&#250;mero de instru&#231;&#245;es a dar aos interpretador fosse o m&#237;nimo poss&#237;vel.</p><h1>Discuss&#227;o/Conclus&#227;o </h1><p>Decidimos dividir esta tarefa em partes mais pequenas. Primeiramente decidimos fazer a convers&#227;o total dos corredores. Ap&#243;s isto, pegamos no resultado desta conver&#231;&#227;o e retir&#225;mos os corredores que apareciam repetidos, ou seja, substitu&#237;mos estes por Repeat n, onde o n seria o &#237;ndice da primeira vez que este corredor aparece. Para isto, escolhemos utilizar acumuladores, entre eles uma lista que come&#231;a vazia e os corredores v&#227;o sendo adicionados nesta. Caso j&#225; tenham corredores iguais, estes n s&#227;o adicionados e inserimos Repeat n conforme explicado anteriormente. O outro acumulador &#233; relacionado com os &#237;ndices dos corredores no labirinto e come&#231;a em 1 pois j&#225; contamos que o corredor 0 &#233; sempre logo adicionado &#224; lista vazia justamente por ser o primeiro corredor. Em conclus&#227;o, achamos uma tarefa interessante pois nos obrigou a utilizar acumuladores e aprender mais sobre Haskell em si. Al&#233;m disso, tamb&#233;m &#233; importante para uma pessoa analisar a quantidade de pe&#231;as do labirinto e se h&#225; corredores iguais de maneira mais f&#225;cil e mais clara, diferentemente do que temos no terminal por serem strings pequenas e muito juntas. E ficamos felizes por termos conseguido concluir. </p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:idPieceCorridor">idPieceCorridor</a> :: [<a href="Types.html#t:Piece" title="Types">Piece</a>] -&gt; Int -&gt; <a href="Types.html#t:Piece" title="Types">Piece</a></li><li class="src short"><a href="#v:samePiece">samePiece</a> :: <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; [<a href="Types.html#t:Piece" title="Types">Piece</a>]</li><li class="src short"><a href="#v:instructPieces">instructPieces</a> :: [<a href="Types.html#t:Piece" title="Types">Piece</a>] -&gt; [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)]</li><li class="src short"><a href="#v:partitionCorridor">partitionCorridor</a> :: <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; [[<a href="Types.html#t:Piece" title="Types">Piece</a>]]</li><li class="src short"><a href="#v:readCorridor">readCorridor</a> :: [[<a href="Types.html#t:Piece" title="Types">Piece</a>]] -&gt; [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)]</li><li class="src short"><a href="#v:readMaze">readMaze</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></li><li class="src short"><a href="#v:getInstructions">getInstructions</a> :: <a href="Types.html#t:Instructions" title="Types">Instructions</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></li><li class="src short"><a href="#v:repeatNth">repeatNth</a> :: [(Int, <a href="Types.html#t:Instruction" title="Types">Instruction</a>)] -&gt; [(Int, <a href="Types.html#t:Instruction" title="Types">Instruction</a>)] -&gt; Int -&gt; [(Int, <a href="Types.html#t:Instruction" title="Types">Instruction</a>)]</li><li class="src short"><a href="#v:compactMaze">compactMaze</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:idPieceCorridor" class="def">idPieceCorridor</a> :: [<a href="Types.html#t:Piece" title="Types">Piece</a>] -&gt; Int -&gt; <a href="Types.html#t:Piece" title="Types">Piece</a> <a href="#v:idPieceCorridor" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que retorna a pe&#231;a referente a posi&#231;&#227;o dada numa lista de pe&#231;as</p></div></div><div class="top"><p class="src"><a id="v:samePiece" class="def">samePiece</a> :: <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; [<a href="Types.html#t:Piece" title="Types">Piece</a>] <a href="#v:samePiece" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que retorna a lista das primeiras pe&#231;as iguais</p><pre>takeWhile (==x) (x:xs)
</pre><ul><li>Ir&#225; a lista de pe&#231;as at&#233; que encontre uma diferente</li></ul></div></div><div class="top"><p class="src"><a id="v:instructPieces" class="def">instructPieces</a> :: [<a href="Types.html#t:Piece" title="Types">Piece</a>] -&gt; [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)] <a href="#v:instructPieces" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que retorna instruction de uma lista de pe&#231;as iguais</p><pre>length p
</pre><ul><li>Quantidade desta pe&#231;a na lista, j&#225; que usaremos para listas que s&#243; possuem a mesma pe&#231;a</li></ul></div></div><div class="top"><p class="src"><a id="v:partitionCorridor" class="def">partitionCorridor</a> :: <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; [[<a href="Types.html#t:Piece" title="Types">Piece</a>]] <a href="#v:partitionCorridor" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que ao receber um corredor, o divide em listas de pe&#231;as iguais</p><pre>samePiece (x:xs)
</pre><ul><li>Aplica a fun&#231;&#227;o samePiece ao corredor para ter uma lista com pe&#231;as iguais at&#233; que apare&#231;a uma diferente</li></ul><pre>partitionCorridor (dropWhile (==x) xs)
</pre><ul><li>Aplica recursivamente ao resto da lista, sendo necess&#225;rio a utiliza&#231;&#227;o da dropWhile para que n&#227;o repita para as pe&#231;as iniciais que j&#225; foram lidas</li></ul></div></div><div class="top"><p class="src"><a id="v:readCorridor" class="def">readCorridor</a> :: [[<a href="Types.html#t:Piece" title="Types">Piece</a>]] -&gt; [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)] <a href="#v:readCorridor" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que ao receber uma lista de lista de pe&#231;as, retorna as instructions</p></div></div><div class="top"><p class="src"><a id="v:readMaze" class="def">readMaze</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a> <a href="#v:readMaze" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dado um labirinto devolve as instructions</p></div></div><div class="top"><p class="src"><a id="v:getInstructions" class="def">getInstructions</a> :: <a href="Types.html#t:Instructions" title="Types">Instructions</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a> <a href="#v:getInstructions" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que recebe o labirinto em Instructions da primeira transforma&#231;&#227;o e o devolve de forma com que os corredores repetidos tenham sido trocados pelos Repeats</p><h1>Modifica&#231;&#227;o do labirinto em forma de Instructions para que corredores repetidos estejam na forma de <strong>Repeat n</strong>, na qual n &#233; o &#237;ndice da <strong>primeira</strong> ocorr&#234;ncia deste corredor no labirinto</h1><h2>Explica&#231;&#227;o breve da fun&#231;&#227;o getInstructions: </h2><pre>map snd $ sort $ repeatNth [] l' 1 
</pre><ul><li>sort para que estejam em ordem de acordo com Int do tuplo (Int,Instruction);</li><li>map snd para ter apenas Instruction do tuplo (Int,Instruction) recebido da fun&#231;&#227;o repeatNth; </li><li>repeatNth [] l' 1 - [] para que comece com [] e o primeiro corredor seja adicionado a esta lista vazia. Deste modo, ir&#225; percorrer o restante da lista acumulando os resultados</li><li>acumulador come&#231;a em 1, pois o &#237;ndice come&#231;a em 0;</li></ul><pre>where l' = zip [0..] l
</pre><ul><li>Deste modo temos o labirinto em formato (Int,Instruction) no qual o Int &#233; o &#237;ndice da Instruction no labirinto;</li></ul></div></div><div class="top"><p class="src"><a id="v:repeatNth" class="def">repeatNth</a> :: [(Int, <a href="Types.html#t:Instruction" title="Types">Instruction</a>)] -&gt; [(Int, <a href="Types.html#t:Instruction" title="Types">Instruction</a>)] -&gt; Int -&gt; [(Int, <a href="Types.html#t:Instruction" title="Types">Instruction</a>)] <a href="#v:repeatNth" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o auxiliar respons&#225;vel por trocar elementos repetidos por Repeat n</p><h2>Explica&#231;&#227;o pormenorizada da fun&#231;&#227;o</h2><pre>elem x (map snd l2) = repeatNth l2 ls (acc+1) 
</pre><ul><li>Se o elemento est&#225; em l2 &#233; porque &#233; repetido</li></ul><pre>mapAcc == []  = repeatNth ((i,x):l2) ls (acc+1)
</pre><ul><li>Insere os elementos em l2 quando n&#227;o s&#227;o repetidos</li></ul><pre>otherwise = repeatNth (((i,x):l2)++repeats) ls (acc+1)
</pre><ul><li>Insere os elementos quando s&#227;o repetidos em l2</li></ul><pre>mapAcc  = map (+acc) (elemIndices x (map snd ls))
</pre><ul><li>Aqui percebe-se a necessidade para o acc come&#231;ar em 1 explicado anteriormente</li></ul><pre>repeats = map (y -&gt; (y,(Repeat i)) ) mapAcc 
</pre><ul><li>Adiciona Repeat i no qual i equivale &#224; primeira ocorr&#234;ncia no labirinto e y a posi&#231;&#227;o na qual deve estar</li></ul></div></div><div class="top"><p class="src"><a id="v:compactMaze" class="def">compactMaze</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a> <a href="#v:compactMaze" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o final para compactar o labirinto</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>