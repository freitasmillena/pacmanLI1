<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Tarefa4</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Maria Pinheiro &lt;mcardosorp@gmail.com&gt;;<br />Millena Santos &lt;freitasmillena27@gmail.com&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Tarefa4</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Um m&#243;dulo Haskell que calcula o efeito da passagem de um instante de tempo num estado do jogo.</p><h1>Introdu&#231;&#227;o</h1><p>A tarefa 4 foi a respons&#225;vel por introduzir a passagem de tempo ao jogo e fazer com que todos os jogadores efetuassem jogadas ao passar do tempo. Foi a partir desta tarefa que pudemos sentir realmente o jogo e visualizar o trabalho feito at&#233; ent&#227;o, pois antes era est&#225;tico e agora somos capazes de ver as mudan&#231;as.</p><h1>Objetivos</h1><p>O nossos principais objetivos era fazer o Pacman fosse realmente afetado pela passagem de tempo. Ou seja, caso estivesse Mega, realmente tivesse seu tempo Mega a ser diminu&#237;do at&#233; que voltasse a se encontrar em estado Normal e tamb&#233;m que os Fantasmas pudessem reagir &#224; passagem de tempo ao efetuar jogadas.</p><p>No caso do Pacman, da mesma forma que o jogo original, enquanto uma tecla n&#227;o fosse carregada para determinar a pr&#243;xima orienta&#231;&#227;o, este permaneceria a efetuar jogadas na orienta&#231;&#227;o que se encontra at&#233; que o usu&#225;rio determinasse o contr&#225;rio.</p><p>Os fantasmas efetuariam jogadas de acordo com a fun&#231;&#227;o <strong>ghostPlay</strong> implementada na Tarefa 5 de modo com que fossem inteligentes para perseguir o Pacman caso estivessem Alive ou fugir do Pacman caso estivessem Dead. Ou seja, trazer mais dificuldade para o jogo e maior intera&#231;&#227;o e emo&#231;&#227;o para o usu&#225;rio.</p><h1>Discuss&#227;o e Conclus&#227;o</h1><p>Decidimos que seria mais pr&#225;tico se divid&#237;ssemos o passTime para Pacman e para fantasmas.</p><h3><em>Pacman</em></h3><p>Como nosso tempo escolhido para o Pacman permanecer <strong>Mega</strong> foi de 10 segundos e o defaultDelayTime &#233; de 250ms, chegamos &#224; conclus&#227;o de que o tempo Mega deveria diminuir 1 segundo a cada 4 steps. Por isto, separamos a condi&#231;&#227;o na qual o step &#233; m&#250;ltiplo de 4 e o Pacman est&#225; Mega.</p><p>Para que o o Pacman pudesse ter seu estado atualizado com a passagem do tempo, resolvemos modificar o Pacman recebido no estado atual ao utilizar as fun&#231;&#245;es que fazem com que seu tempo Mega seja diminu&#237;do em 1 e que volte ao Normal caso alcance 0. </p><p>Atualizamos o estado do jogo recebido de modo a substituir o Pacman anterior pelo atual e chamamos a fun&#231;&#227;o <strong>play</strong> da tarefa 2 para o Pacman de modo que permane&#231;a na mesma orienta&#231;&#227;o e que utilize o Pacman j&#225; atualizado. Assim, conseguimos evitar que o tempo Mega ficasse negativo, que o Pacman n&#227;o voltasse  a Normal e, consequentemente, os fantasmas a Alive e que a passagem de tempo funcionasse conforme o esperado.</p><h3><em>Fantasmas</em></h3><p>Nesta etapa, come&#231;amos pelo racioc&#237;nio de que a velocidade no jogo seria 1. Quando os fantasmas encontram-se <strong>Dead</strong>, suas velocidades s&#227;o reduzidas pela metade, pelo qual s&#243; efetuariam jogadas de 2 em 2 steps.</p><p>Estamos conscientes de que num jogo com passagens de n&#237;veis e maiores dificuldades, haveria uma implementa&#231;&#227;o de velocidades diferentes. Infelizmente, por quest&#245;es de log&#237;stica, n&#227;o tivemos a oportunidade de implementar isto desta vez. Portanto, temos apenas duas velocidades poss&#237;veis: 1.0 e 0.5.</p><p>Portanto, separamos a passTime para os fantasmas para quando o step fosse m&#250;ltiplo de 2, na qual todos os fantasmas efetuam jogadas e, caso n&#227;o seja, apenas os <strong>Alive</strong> que possuem velocidade 1.0 que efetuam jogadas.</p><p>Encontramos a dificuldade em como aplicar isto na fun&#231;&#227;o de modo que todos os fantasmas efetuassem jogadas e que obtiv&#233;ssemos um estado final do jogo apenas ap&#243;s todos os fantasmas jogarem. Pois esta recebe um estado do jogo e, desta vez, n&#227;o temos apenas um jogador como para o Pacman, mas temos v&#225;rios fantasmas. </p><p>Como usamos a ghostPlay para que os fantasmas fossem inteligentes, temos uma lista de jogadas. Sendo cada elemento da lista a jogada para um fantasma com um id espec&#237;fico.</p><p>Optamos por fazer com que o estado do jogo acumulasse at&#233; que devolvesse o estado final. Ou seja, o primeiro fantasma faz sua jogada utilizando o estado recebido pela fun&#231;&#227;o. Esta jogada ir&#225; devolver um novo estado que ser&#225; utilizado para a jogada do pr&#243;ximo fantasma e, assim, sucessivamente at&#233; que todos os fantasmas tivessem jogado e devolvesse o estado final.</p><p>Isto nos pareceu uma boa resolu&#231;&#227;o, pois nos ajudou a resolver outra dificuldade que t&#237;nhamos, que era como juntar o estado gerado pela passTime para o Pacman com os gerados pelos fantasmas. Portanto, na fun&#231;&#227;o passTime final, utilizamos o estado do jogo ap&#243;s a jogada do Pacman como o estado do jogo recebido pela passTime dos fantasmas. Com isto, o estado devolvido cont&#233;m todas as jogadas efetuadas.</p><p>Ficamos muito contentes com o resultado final. Esta provavelmente foi a tarefa que achamos mais divertida e que gostamos mais de visualizar o resultado ao termin&#225;-la. Isto porque pudemos sentir a nostalgia ao finalmente poder ver o jogo a funcionar como o Pacman original e pudemos testar e jogar desta vez dinamicamente apenas ao carregar em teclas. Outro motivo pelo qual gostamos tanto desta tarefa foi porque fez com que volt&#225;ssemos &#224; Tarefa 2 e, com isto, conseguimos consertar erros que haviam passados despercebidos e optimizar alguns pormenores. </p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:defaultDelayTime">defaultDelayTime</a> :: Integer</li><li class="src short"><a href="#v:passTime">passTime</a> :: Int -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a></li><li class="src short"><a href="#v:passTimeGhosts">passTimeGhosts</a> :: Int -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a></li><li class="src short"><a href="#v:passTimePac">passTimePac</a> :: Int -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a></li><li class="src short"><a href="#v:timeMegaCD">timeMegaCD</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a></li><li class="src short"><a href="#v:backToNormal">backToNormal</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:defaultDelayTime" class="def">defaultDelayTime</a> :: Integer <a href="#v:defaultDelayTime" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:passTime" class="def">passTime</a> :: Int -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> <a href="#v:passTime" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que recebe um int, equivalente a um step, e o estado atual do jogo, e que devolve um state no qual aplica a a&#231;&#227;o de passar o tempo. Esta fun&#231;&#227;o &#233; <strong>geral</strong> ou seja, para <strong>todos os jogadores</strong> </p><pre>newSt = passTimePac n st 
</pre><ul><li>O estado original &#233; atualizado para o _newSt_, cujo corresponde &#224; atualiza&#231;&#227;o do estado original consuante a aplica&#231;&#227;o da passagem do tempo ao pacman no step n.</li></ul><pre>passTimeGhosts n newSt 
</pre><ul><li>A fun&#231;&#227;o aplica a fun&#231;&#227;o passTimeGhosts a um step n e a um estado newSt, a que vai aplicar a passagem do tempo aos fantasmas ao novo estado (atualizado com a passagem do tempo do pacman), criando, assim o estado final onde foi aplicada a passagem do tempo a todos os jogadores. </li></ul></div></div><div class="top"><p class="src"><a id="v:passTimeGhosts" class="def">passTimeGhosts</a> :: Int -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> <a href="#v:passTimeGhosts" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que recebe um step e um state, e que devolve um state no qual aplica a a&#231;&#227;o de passar o tempo. Esta fun&#231;&#227;o &#233; espeficiamente para os _fantasmas_</p><pre>plays = ghostPlay st 
</pre><ul><li>Aplica a fun&#231;&#227;o ghostPlay e retorna a lista de jogadas para todos os fantasmas da lista de jogadores.</li></ul><pre>alives = ghostPlay2 st 
</pre><ul><li>Aplica a fun&#231;&#227;o ghostPlay2 e retorna a lista de jogadas para todos os fantasmas <strong>Alive</strong> da lista de jogadores</li></ul><h2><em>Step m&#250;ltiplo de 2</em></h2><h3>Tornou-ne necess&#225;rio dividir em m&#250;ltiplos de 2 e n&#227;o m&#250;ltiplos, pois, considera-se que a velocidade normal dos fantasmas &#233; <strong>1</strong>, por&#233;m quando est&#227;o <strong>Dead</strong> encontram-se com a velocidade reduzida pela metade. Como o defaultDelayTime &#233; de 250ms, um jogador com velocidade <strong>0.5</strong> ir&#225; efetuar jogadas apenas de 2 em 2 steps.</h3><pre>mod n 2 == 0 = foldl (acc x -&gt; play x acc) st plays
</pre><ul><li>Verifica-se inicialmente se o step &#233; ou n&#227;o m&#250;ltiplo de 2;</li><li>Com isto, aplica-se um foldl cujo acumulador &#233; o state recebido na fun&#231;&#227;o passTimeGhosts e a lista inicial corresponde a lista de jogadas para todos os fantasmas, j&#225; que o step &#233; m&#250;ltiplo de 2;</li><li>Basicamente, ir&#225; chamar a fun&#231;&#227;o play para a primeira jogada da lista de jogadas e o state utilizado ser&#225; o recebido. Isto ir&#225; gerar um novo state. Este novo state ser&#225; utilizado quando chamar novamente a fun&#231;&#227;o play para a segunda jogada da lista de jogadas e, assim, sucessivamente at&#233; que percorra toda a lista de jogadas e devolva o state final no qual todos os fantasmas efetuaruam suas respetivas jogadas.</li></ul><h2><em>Step n&#227;o m&#250;ltiplo de 2</em></h2><pre>otherwise = foldl (acc x -&gt; play x acc) st alives
</pre><ul><li>Neste caso, apenas os fantasmas <strong>Alive</strong>, ou seja, com velocidade <strong>1</strong> que efetuam jogadas;</li><li>O foldl funciona da mesma maneira que acima. Inicia chamando a fun&#231;&#227;o Play para a primeira jogada e utiliza o state recebido e vai acumulando novos states para serem aplicados ao percorrer a lista at&#233; que devolva o state final;</li><li>A diferen&#231;a &#233; que, neste caso, a lista de jogadas a ser percorrida cont&#233;m jogadas apenas para os fantasmas com velocidade <strong>1</strong>.</li></ul></div></div><div class="top"><p class="src"><a id="v:passTimePac" class="def">passTimePac</a> :: Int -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> <a href="#v:passTimePac" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que recebe um int, equivalente a um step e um state, e que devolve um state no qual aplica a a&#231;&#227;o de passar o tempo. Esta fun&#231;&#227;o &#233; espeficiamente para o _pacman_</p><pre>j = getPlayerID $ getPacman (p:ps)
</pre><ul><li>Atrav&#233;s desta express&#227;o conseguimos extrair o player que corresponde ao pacman da lista de jogadores recebida no state, e ap&#243;s isto, conseguimos recolher o id do pacman que corresponder&#225; &#224; letra j.</li></ul><pre>o = getPlayerOrientation $ getPacman (p:ps)
</pre><ul><li>Atrav&#233;s desta express&#227;o conseguimos extrair o player que corresponde ao pacman da lista de jogadores recebida no state, e ap&#243;s isto, conseguimos retirar a orienta&#231;&#227;o do pacman.</li></ul><pre>player = (backToNormal $ timeMegaCD $ getPacman $ getPlayers st )
</pre><ul><li>Atrav&#233;s desta express&#227;o obtemos um player. Inicialmente extraimos a lista de jogadores do State recorrendo &#224; fun&#231;&#227;o getPlayers. Ap&#243;s isto, recolhemos o player que corresponde ao pacman atrav&#233;s da fun&#231;&#227;o getPacman. Por fim, aplicamos por esta ordem, a fun&#231;&#227;o timeMegaCD e a fun&#231;&#227;o backToNormal, que ir&#227;o alterar o timeMega e o pacMode, se necess&#225;rio. O resultado destas a&#231;&#245;es ser&#225; o player.</li></ul><pre>ns = newState st player
</pre><ul><li>Atrav&#233;s desta express&#227;o altera-se o State original, utilizando a fun&#231;&#227;o newState definida na tarefa 2. A fun&#231;&#227;o recebe o State original e um argumento player, que seria um Player atualizado consuante as seguintes condi&#231;&#245;es: 
     &gt;Caso esteja Mega, o timeMega diminui 1;
     &gt;Caso acabe o timeMega, retorna a Normal.</li></ul><h2><em>Pacman Mega e step m&#250;ltiplo de 4</em></h2><h3>Escolhemos step m&#250;ltiplo de 4 pois optamos pelo timeMega de 10 segundos. Como o defaultDelayTime corresponde a 250 ms, isto significa que o timeMega ir&#225; diminuir em 1 a cada 4 jogadas, ou seja, de 4 em 4 steps.</h3><pre>pacMode (getPacman (p:ps)) == Mega &amp;&amp; mod n 4 == 0 = play (Move j o) ns
</pre><ul><li>Verifica-se inicialmente se o pacman est&#225; em estado Mega;</li><li>Se estiver em estado mega verifica-se se o step, que corresponde ao n, &#233; m&#250;ltiplo de 4;</li><li>Se assim acontecer, o state devolvido resultar&#225; da aplica&#231;&#227;o da fun&#231;&#227;o play no pacman. Nesta &#250;ltima, utiliza-se uma jogada (Move j o), onde j seria o id do pacman e o a orienta&#231;&#227;o original do pacman; e utiliza-se um State ns que seria o state atualizado consuante as condi&#231;&#245;es anteriormente descritas.</li></ul><h2><em>Pacman diferente de Mega e step n&#227;o m&#250;ltiplo de 4</em></h2><pre>otherwise = play (Move j o) st
</pre><ul><li>Caso o pacman n&#227;o esteja em estado Mega <strong>ou</strong> caso o step n&#227;o seja m&#250;ltiplo de 4, <strong>ou ambos</strong>, o State devolvido resultar&#225; da aplica&#231;&#227;o da fun&#231;&#227;o play;</li><li>Nesta &#250;ltima utiliza-se uma jogada (Move j o), onde j seria o id do pacman e o a orienta&#231;&#227;o original do pacman e utiliza-se um State, que corresponderia ao State atual que foi recebido na passTimePac.</li></ul></div></div><div class="top"><p class="src"><a id="v:timeMegaCD" class="def">timeMegaCD</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a> <a href="#v:timeMegaCD" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que diminui o timeMega do pacman em 1 consuante as jogadas</p><pre>Mega -&gt; (Pacman (PacState (id, (a,b), v, o, points, lifes) (timeMega - 1) openClosed pacmanMode)) 
</pre><ul><li>Inicialmente verifica-se qual o estado do pacman. Se este for Mega, retira-se 1 ao timeMega. </li></ul><pre>_ -&gt; (Pacman (PacState (id, (a,b), v, o, points, lifes) timeMega openClosed pacmanMode))
</pre><ul><li>Caso o estado do pacman n&#227;o seja Mega, n&#227;o se faz nenhuma altera&#231;&#227;o.</li></ul></div></div><div class="top"><p class="src"><a id="v:backToNormal" class="def">backToNormal</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a> <a href="#v:backToNormal" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que faz com que o pacman volte ao estado normal quando o timeMega atinge o 0</p><pre>Mega -&gt; if timeMega &lt;= 0 then (Pacman (PacState (id, (a,b), v, o, points, lifes) 0 openClosed Normal))
</pre><ul><li>Inicialmente verifica-se qual o estado do pacman. Se este for Mega, dentro existe uma condi&#231;&#227;o que verifica se o timeMega do pacman &#233; igual ou inferior a zero. Se assim for, altera o estado do pacman para Normal.</li><li>Caso o pacman esteja em estado Mega e o timeMega seja superior a 0, o estado mant&#233;m-se Mega.</li></ul><pre>_ -&gt; (Pacman (PacState (id, (a,b), v, o, points, lifes) timeMega openClosed pacmanMode))
</pre><ul><li>Caso o estado do Pacman n&#227;o seja Mega, o estado mant&#233;m-se. </li></ul></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>