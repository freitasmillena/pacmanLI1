<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Tarefa6</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Maria Pinheiro &lt;mcardosorp@gmail.com&gt;;<br />Millena Santos &lt;freitasmillena27@gmail.com&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Tarefa6</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Um m&#243;dulo Haskell que impleta um rob&#244; que jogue Pacman automaticamente</p><h1>Introdu&#231;&#227;o</h1><p>A tarefa 6 foi a tarefa na qual implementamos um bot para efetuar jogadas automaticamente com o Pacman. Para que desta forma, possa procurar ganhar o jogo.</p><h1>Objetivos</h1><p>O nosso objetivo principal foi fazer com que de acordo com o estado atual do Pacman no jogo, pudesse seguir estrat&#233;gias para tornar-se <strong>Mega</strong> e ganhar pontos ao comer fantasmas ou simplesmente fugir dos fantasmas para que n&#227;o perdesse vidas e, consequentemente, o jogo.</p><h1>Discuss&#227;o e conclus&#227;o </h1><p>Come&#231;amos por pensar que, caso o Pacman estivesse em modo <strong>Normal</strong> ou <strong>Dying</strong> que sua prioridade seria alcan&#231;ar uma <strong>Food Big</strong> para que pudesse se tornar Mega e, assim, recuperar-se no jogo. Para isto, fizemos com que a cada jogada obtiv&#233;ssemos a lista das coordenadas das comidas grandes remanescentes no labirinto. Em seguida, utilizamos a mesma estrat&#233;gia utilizada na Tarefa 5. Selecionamos a coordenada da comida grande mais pr&#243;xima da coordenada atual do Pacman e, em seguida, observamos as coordenadas poss&#237;veis paraa o Pacman e que n&#227;o tivessem <strong>Wall</strong> e optar&#237;amos pela que fosse necess&#225;rio o menor n&#250;mero de jogadas o poss&#237;vel para alcan&#231;&#225;-la.</p><p>Chegamos num impasse no qual h&#225; a possibilidade de que n&#227;o exista mais comidas grandes no labirinto. Com isto, decidimos optar por fazer com que o Pacman fuja dos fantasmas. Para isto, a estrat&#233;gia utilizada foi procurar qual fantasma encontra-se mais pr&#243;ximo da coordenada atual do Pacman e fazer com que o Pacman siga para uma coordenada que precise do maior n&#250;mero de jogadas o poss&#237;vel para o fantasma a alcan&#231;ar. Tamb&#233;m utilizamos estrat&#233;gias e fun&#231;&#245;es similares da Tarefa 5.</p><p>E, finalmente, caso o Pacman estivesse <strong>Mega</strong>, optamos procurar o fantasma mais pr&#243;ximo do Pacman, ou seja que &#233; necess&#225;rio menor n&#250;mero de jogadas com o Pacman para alcan&#231;&#225;-lo, e fazer com que o persiga. Para o perseguir, utilizamos estrat&#233;gias e fun&#231;&#245;es tamb&#233;m utilizadas na Tarefa 5.</p><p>O facto desta tarefa ter sido feita ap&#243;s a tarefa 5 foi &#243;timo, pois pudemos desenvolver racioc&#237;nios na 5 j&#225; pensando que poderiam ser reaplicados na 6. Esta talvez foi a mais desafiadora, pois a ideia de criar um bot j&#225; &#233; por si s&#243; tentadora e, ao conseguir estabelecer estrat&#233;gias para diferentes possibilidades e fazer com que o bot as execute &#233; fascinante. Em conclus&#227;o, esta tarefa foi divertida pois tivemos que analisar as possibilidades levando em considera&#231;&#227;o que nossos fantasmas tamb&#233;m procuram estrat&#233;gias e ficamos felizes com o que conseguimos.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:bot">bot</a> :: Int -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; Maybe <a href="Types.html#t:Play" title="Types">Play</a></li><li class="src short"><a href="#v:coordsFoodBig">coordsFoodBig</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; [<a href="Types.html#t:Coords" title="Types">Coords</a>]</li><li class="src short"><a href="#v:goToFood">goToFood</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; [<a href="Types.html#t:Corridor" title="Types">Corridor</a>] -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a></li><li class="src short"><a href="#v:getCoordsL">getCoordsL</a> :: [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; [<a href="Types.html#t:Coords" title="Types">Coords</a>]</li><li class="src short"><a href="#v:chaseGhosts">chaseGhosts</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a></li><li class="src short"><a href="#v:getOut">getOut</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:bot" class="def">bot</a> :: Int -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; Maybe <a href="Types.html#t:Play" title="Types">Play</a> <a href="#v:bot" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dado o id e o estado do jogo, devolve a jogada necess&#225;ria de modo que o bot consiga o melhor desempenho</p><h1>Bot Pacman</h1><h2><em>Pacman Mega</em></h2><pre>Just (Move x (chaseGhosts pac st))
</pre><ul><li>Caso o Pacman esteja mega, seu objetivo &#233; alcan&#231;ar o fantasma mais pr&#243;ximo de onde est&#225; atualmente. Para isto, aplica-se a fun&#231;&#227;o <strong>chaseGhosts</strong> ao estado do jogo recebido </li></ul><h2><em>Pacman diferente de Mega</em></h2><p>Neste caso, o objetivo do Pacman &#233; consumir <strong>Food Big</strong> a fim de tornar-se Mega e perseguir fantasmas. Por&#233;m, pode haver um momento no qual n&#227;o h&#225; mais <strong>Food Big</strong>. 
Tornou-se necess&#225;rio separar em duas condi&#231;&#245;es:</p><h3>Quando n&#227;o h&#225; mais <strong>Food Big</strong> restantes no labirinto </h3><p>Quando n&#227;o h&#225; mais, a fun&#231;&#227;o coordsFoodBig retorna uma lista vazia, com isto, o Pacman muda sua estrat&#233;gia de ir at&#233; a <strong>Food Big</strong> para tornar-se Mega e precisa fugir do fantasma que encontra-se mais pr&#243;ximo.</p><pre>Just (Move x (getOut pac st))
</pre><ul><li>Logo, a <strong>Orientation</strong> utilizada na Play &#233; recebida atrav&#233;s da fun&#231;&#227;o getOut </li></ul><h3>Quando h&#225; <strong>Food Big</strong> restantes no labirinto</h3><pre>Just (Move x (goToFood pac m))
</pre><ul><li>Ou seja, a <strong>Orientation</strong> utilizada na Play &#233; recebida atrav&#233;s da fun&#231;&#227;o goToFood </li></ul></div></div><div class="top"><p class="src"><a id="v:coordsFoodBig" class="def">coordsFoodBig</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; [<a href="Types.html#t:Coords" title="Types">Coords</a>] <a href="#v:coordsFoodBig" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dado um labirinto, devolve a lista com as coordenadas das comidas grandes </p><pre>if (maze !! y) !! x == Food Big then acc2 ++ [(y,x)] else acc2
</pre><ul><li>(maze !! y) retorna o corredor e ao fazer !! x retorna a pe&#231;a neste corredor </li><li>Caso retorne Food Big, h&#225; a jun&#231;&#227;o do acc2 que come&#231;a como lista vazia ++ [(y,x)] que &#233; a coordenada desta Food Big encontrada</li><li>Caso n&#227;o retorne Food Big, retorna apenas o acc2 que de in&#237;cio &#233; uma lista vazia, mas ap&#243;s um tempo ser&#225; a lista atual com as coordenadas at&#233; ent&#227;o encontradas que possuem Food Big</li></ul><pre>[] [0..(length (head maze) - 1)]
</pre><ul><li>A lista vazia &#233; o acc2 inicial</li><li>A lista inicial pela qual o foldl ir&#225; percorrer &#233; [0..(length (head maze) - 1)], na qual (length (head maze) - 1) devolve o &#237;ndice da &#250;ltima pe&#231;a do corredor</li></ul><pre>foldl (acc y -&gt; acc ++ (foldl (acc2 x -&gt; if (maze !! y) !! x == Food Big then acc2 ++ [(y,x)] else acc2)) [] [0..(length (head maze) - 1)]) [] [0..(length maze - 1)]
</pre><ul><li>Este foldl faz a jun&#231;&#227;o do acc inicial que neste caso &#233; a lista vazia com o resultado do foldl explicado acima</li><li>A lista que percorre &#233; [0..(length maze - 1)] na qual (length maze - 1) devolve o &#237;ndice do &#250;ltimo corredor do labirinto</li></ul></div></div><div class="top"><p class="src"><a id="v:goToFood" class="def">goToFood</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; [<a href="Types.html#t:Corridor" title="Types">Corridor</a>] -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a> <a href="#v:goToFood" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que recebe o pacman e o labirinto e, com isto, seleciona a coordenada da <strong>Food Big</strong> mais pr&#243;xima e retorna a orienta&#231;&#227;o que deve ser utilizada na pr&#243;xima jogada para que o pacman v&#225; at&#233; esta coordenada
<code>
poss     = [(a+1,b),(a-1,b),(a,b+1),(a,b-1)]
</code>
*Estas s&#227;o as jogadas existentes para o Pacman: D, U, R, L respetivamente. </p><pre>lp       = notWall poss (x:xs)
</pre><ul><li>Nesta etapa, s&#227;o selecionadas apenas as coordenadas que n&#227;o cont&#233;m <strong>Wall</strong> das coordenadas relativas &#224;s jogadas existentes</li></ul><pre>lc       = coordsFoodBig (x:xs) 
</pre><ul><li>Estas &#233; a lista de coordenadas das <strong>Food Big</strong> no labirinto </li></ul><pre>coordBig = bestCoord lc (a,b)
</pre><ul><li>Nesta etapa, tornou-se necess&#225;rio selecionar a coordenada da <strong>Food Big</strong> mais pr&#243;xima ao Pacman utilizando a fun&#231;&#227;o presente na Tarefa 5 </li></ul><pre>best     = bestCoord lp coordBig
</pre><ul><li>Com isto, comparamos as coordenadas que n&#227;o cont&#233;m <strong>Wall</strong>, ou seja, as que o Pacman realmente pode ir com a coordenada da <strong>Food Big</strong> mais pr&#243;xima a fim de selecionar qual coordenada poss&#237;vel do Pacman que o levar&#225; para mais pr&#243;ximo da <strong>Food Big</strong></li></ul><pre>whichOrientation (a,b) best
</pre><ul><li>Por fim, comparamos a coordenada na qual o Pacman se encontra, com a coordenada que ele quer ir na pr&#243;xima jogada a fim de determinar a <strong>Orientation</strong> que ser&#225; necess&#225;ria na Play </li></ul></div></div><div class="top"><p class="src"><a id="v:getCoordsL" class="def">getCoordsL</a> :: [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; [<a href="Types.html#t:Coords" title="Types">Coords</a>] <a href="#v:getCoordsL" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dada uma lista de jogadores, devolve a lista com as coordenadas de cada jogador</p><ul><li>Esta fun&#231;&#227;o torna-se necess&#225;ria para que possamos selecionar as coordenadas de todos os fantasmas presentes no labirinto</li></ul></div></div><div class="top"><p class="src"><a id="v:chaseGhosts" class="def">chaseGhosts</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a> <a href="#v:chaseGhosts" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dado o Pacman e o estado do jogo, procura qual fantasma est&#225; mais pr&#243;ximo e determina qual deve ser a orienta&#231;&#227;o utilizada na pr&#243;xima jogada para que o pacman v&#225; at&#233; este fantasma</p><pre>coordsGhosts = getCoordsL $ getGhosts (p:ps)
</pre><ul><li>Nesta etapa, selecionamos os fantasmas da lista de jogadores e, a seguir, selecionamos suas coordenadas no labirinto</li></ul><pre>coordToGo    = bestCoord (coordsGhosts) (a,b)
</pre><ul><li>Precisamos saber qual o fantasma que est&#225; mais pr&#243;ximo do Pacman, para que o Pacman ao estar Mega possa perseguir o fantasma</li><li>Com isto, aplicamos a fun&#231;&#227;o x da Tarefa 5 para selecionar a coordenada na qual o Pacman precisa de menos jogadas para alcan&#231;ar</li></ul><pre>lc           = [(a+1,b),(a-1,b),(a,b+1),(a,b-1)]
</pre><ul><li>Estas s&#227;o as jogadas existentes para o Pacman: D, U, R, L respetivamente. </li></ul><pre>poss         = notWall lc (x:xs)
</pre><ul><li>Nesta etapa, s&#227;o selecionadas apenas as coordenadas que n&#227;o cont&#233;m <strong>Wall</strong> das coordenadas relativas &#224;s jogadas existentes</li></ul><pre>best         = bestCoord poss coordToGo 
</pre><ul><li>Aqui, utiliza-se a fun&#231;&#227;o da Tarefa 5 para comparar as coordenadas poss&#237;veis que o Pacman pode alcan&#231;ar, ou seja, as que n&#227;o possuem <strong>Wal</strong> com a coordenada do fantasma mais pr&#243;ximo e selecionar qual destas coordenadas requer o menor n&#250;mero de jogadas para o Pacman </li></ul><pre>whichOrientation (a,b) best
</pre><ul><li>E, com isto, ao comparar a coordenada atual do Pacman com a que ele quer ir na p&#341;oxima jogada, seleciona-se a <strong>Orientation</strong> necess&#225;ria para Play </li></ul></div></div><div class="top"><p class="src"><a id="v:getOut" class="def">getOut</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a> <a href="#v:getOut" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dado o Pacman e o estado do jogo, procura qual fantasma est&#225; mais pr&#243;ximo e determina qual deve ser a orienta&#231;&#227;o utilizada na pr&#243;xima jogada para que o pacman se distancie deste fantasma</p><pre>coordsGhosts = getCoordsL $ getGhosts (p:ps)
</pre><ul><li>Seleciona as coordernadas dos fantasmas presentes no labirinto
<code>
closest      = bestCoord (coordsGhosts) (a,b)
</code></li><li>Utiliza-se a fun&#231;&#227;o da Tarefa 5 para selecionar a coordenada do fantasma que est&#225; mais pr&#243;ximo do Pacman </li></ul><pre>lc           = [(a+1,b),(a-1,b),(a,b+1),(a,b-1)]
</pre><ul><li>Estas s&#227;o as jogadas existentes para o Pacman: D, U, R, L respetivamente. </li></ul><pre>poss         = notWall lc (x:xs)
</pre><ul><li>Nesta etapa, s&#227;o selecionadas apenas as coordenadas que n&#227;o cont&#233;m <strong>Wall</strong> das coordenadas relativas &#224;s jogadas existentes</li></ul><pre>best         = betterRun poss closest
</pre><ul><li>Como o Pacman precisa ir para uma coordenada mais longe que a coordenada do fantasma mais pr&#243;ximo, utiliza-se a fun&#231;&#227;o betterRun presente na Tarefa 5 para determinar qual a pr&#243;xima coordenada do Pacman</li></ul><pre>whichOrientation (a,b) best
</pre><ul><li>E, com isto, ao comparar a coordenada atual do Pacman com a que ele quer ir na p&#341;oxima jogada, seleciona-se a <strong>Orientation</strong> necess&#225;ria para Play </li></ul></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>