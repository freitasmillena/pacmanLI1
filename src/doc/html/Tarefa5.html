<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Tarefa5</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Maria Pinheiro &lt;mcardosorp@gmail.com&gt;;<br />Millena Santos &lt;freitasmillena27@gmail.com&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Tarefa5</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Um m&#243;dulo Haskell que implementa um comportamento para os fantasmas para que fiquem inteligentes e escolham quais estrat&#233;gias a seguir consuante o estado do jogo.</p><h1>Introdu&#231;&#227;o</h1><p>A tarefa 5 foi a respons&#225;vel por implementar o comportamento inteligente para os fantasmas. A fun&#231;&#227;o objetivo desta tarefa <strong>ghostPlay</strong> &#233; necess&#225;ria para a realiza&#231;&#227;o tamb&#233;m da Tarefa 4.</p><h1>Objetivos</h1><p>Nosso principal objetivo era que os fantasmas pudessem perseguir ou fugir do Pacman de acordo com seu estado no jogo, para atribuir emo&#231;&#227;o e dificuldade para o usu&#225;rio, mas de uma forma que n&#227;o tornasse o jogo totalmente imposs&#237;vel. Para que tamb&#233;m n&#227;o se tornasse muito f&#225;cil, tivemos como objetivo encontrar uma forma com que os fantasmas pudessem ter personalidades diferentes que influenciariam suas escolhas para fugir ou perseguir o Pacman.</p><h1>Discuss&#227;o e conclus&#227;o</h1><p>Decidimos implementar personalidades diferentes. A princ&#237;pio, pensamos em alterar o ficheiro Types que cont&#233;m o estado completo dos fantasmas e adicionar a personalidade para que fosse utilizada de modo a escolher a estrat&#233;gia. Por&#233;m, acabamos por optar por uma solu&#231;&#227;o mais simples e com maior probabilidade de efici&#234;ncia. Separamos os fantasmas por id par e &#237;mpar. Os de id par sempre tentam alcan&#231;ar ou fugir da coordenada atual do Pacman e, os de id &#237;mpar tentam prever em qual coordenada o Pacman ir&#225; se encontrar ap&#243;s 4 jogadas, de acordo com a orienta&#231;&#227;o atual, e alcan&#231;ar ou fugir desta.</p><p>Come&#231;amos por definir como saber&#237;amos a dist&#226;ncia entre o fantasma e o Pacman. Decidimos diminuir suas coordenadas e, desta forma, conseguimos obter o n&#250;mero de jogadas necess&#225;rio para que o fantasma chegue at&#233; o Pacman. Isto foi utilizado para fugir e perseguir, a primeira ao escolher de forma com que fosse necess&#225;rio o maior n&#250;mero de jogadas e a segunda ao escolher o menor.</p><p>Chegamos num impasse em como determinar a orienta&#231;&#227;o do fantasma para a pr&#243;xima jogada. Chegamos &#224; conclus&#227;o de que seria mais simples observar ao redor do fantasma para onde ele poderia ir. Os jogadores podem se movimentar verticalmente e horizontalmente. Utilizamos isto e depois filtramos para selecionar apenas as coordenadas que realmente alterariam a posi&#231;&#227;o do fantasma, ou seja, as que n&#227;o possuem <strong>Wall</strong>. Desta forma, com estas coordenadas fomos capazes de realizar o que foi explicado anteriormente: calcular a diferen&#231;a entre essas coordenadas e a coordenada do Pacman (atual ou prevista) e escolher a que tivesse menor ou maior n&#250;meros de jogadas.</p><p>Encontramos uma dificuldade que, como escolhemos a fun&#231;&#245;es <strong>maximum</strong> e <strong>minimum</strong>, estas comparavam os primeiros elementos dos tuplos com as jogadas para determinar o menor ou maior. Isto n&#227;o era eficaz, pois um tuplo (0,3) -<em>3 jogadas</em>- seria dado como o menor mesmo se houvesse um (1,0) -<em>1 jogada</em>-. Portanto, lembramos de como podemos calcular a dist&#226;ncia &#224; origem e adaptamos ao cen&#225;rio que temos. Desta forma, resultou conforme quer&#237;amos.</p><p>Quando um fantasma morre, no nosso jogo, volta exatamente para o centro da casa de fantasmas. Portanto, tivemos que implementar a condi&#231;&#227;o na qual o fantasma encontra-se nesta coordenada. Assim, tendo que usar a pr&#243;xima orienta&#231;&#227;o para cima a fim de sair da casa de fantasmas.</p><p>Em conclus&#227;o, ficamos contentes com o comportamento dos nossos fantasmas. Esta tarefa foi muito interessante de realizar, pois nos fez realmente pensar por muitos dias, conversar muito e pesquisar muito para elaborar racioc&#237;nios e estrat&#233;gias que fizessem sentido e fazer com que funcionassem. A princ&#237;pio, quer&#237;amos partir pela ideia do caminho mais curto ao aplicar o algoritmo de Dijkstra ou A*, por&#233;m ao pesquisar percebemos que isto iria precisar de mais tempo e talvez n&#227;o fosse a melhor solu&#231;&#227;o por quest&#245;es de tornar o jogo mais pesado ou menos fluido. </p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:coordDif">coordDif</a> :: <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></li><li class="src short"><a href="#v:isitWall">isitWall</a> :: <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; [<a href="Types.html#t:Corridor" title="Types">Corridor</a>] -&gt; Bool</li><li class="src short"><a href="#v:notWall">notWall</a> :: [<a href="Types.html#t:Coords" title="Types">Coords</a>] -&gt; [<a href="Types.html#t:Corridor" title="Types">Corridor</a>] -&gt; [<a href="Types.html#t:Coords" title="Types">Coords</a>]</li><li class="src short"><a href="#v:nextCoordP">nextCoordP</a> :: <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></li><li class="src short"><a href="#v:absList">absList</a> :: [<a href="Types.html#t:Coords" title="Types">Coords</a>] -&gt; [<a href="Types.html#t:Coords" title="Types">Coords</a>]</li><li class="src short"><a href="#v:square">square</a> :: <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; Float</li><li class="src short"><a href="#v:index-39-">index'</a> :: Float -&gt; [Float] -&gt; Int</li><li class="src short"><a href="#v:whichOrientation">whichOrientation</a> :: <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a></li><li class="src short"><a href="#v:betterRun">betterRun</a> :: [<a href="Types.html#t:Coords" title="Types">Coords</a>] -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></li><li class="src short"><a href="#v:littleRunaway">littleRunaway</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; [<a href="Types.html#t:Corridor" title="Types">Corridor</a>] -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a></li><li class="src short"><a href="#v:scatterMode">scatterMode</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; Int -&gt; <a href="Types.html#t:Play" title="Types">Play</a></li><li class="src short"><a href="#v:bestCoord">bestCoord</a> :: [<a href="Types.html#t:Coords" title="Types">Coords</a>] -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></li><li class="src short"><a href="#v:goToPac">goToPac</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; [<a href="Types.html#t:Corridor" title="Types">Corridor</a>] -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a></li><li class="src short"><a href="#v:chaseMode">chaseMode</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; Int -&gt; <a href="Types.html#t:Play" title="Types">Play</a></li><li class="src short"><a href="#v:runOrChase">runOrChase</a> :: [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; [<a href="Types.html#t:Play" title="Types">Play</a>]</li><li class="src short"><a href="#v:ghostPlay">ghostPlay</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; [<a href="Types.html#t:Play" title="Types">Play</a>]</li><li class="src short"><a href="#v:ghostPlay2">ghostPlay2</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; [<a href="Types.html#t:Play" title="Types">Play</a>]</li><li class="src short"><a href="#v:getGhosts-39-">getGhosts'</a> :: [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>]</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:coordDif" class="def">coordDif</a> :: <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> <a href="#v:coordDif" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dado uma coordenada e outra coordenada, calcula a diferen&#231;a entre elas</p></div></div><div class="top"><p class="src"><a id="v:isitWall" class="def">isitWall</a> :: <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; [<a href="Types.html#t:Corridor" title="Types">Corridor</a>] -&gt; Bool <a href="#v:isitWall" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dado uma coordenada e uma lista de corredores, ou seja, um labirinto, diz se h&#225; ou n&#227;o <strong>Wall</strong> nesta coordenada</p></div></div><div class="top"><p class="src"><a id="v:notWall" class="def">notWall</a> :: [<a href="Types.html#t:Coords" title="Types">Coords</a>] -&gt; [<a href="Types.html#t:Corridor" title="Types">Corridor</a>] -&gt; [<a href="Types.html#t:Coords" title="Types">Coords</a>] <a href="#v:notWall" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que recebe lista de coordenadas em volta do fantasma e determina as que ele pode ir, ou seja, que n&#227;o h&#225; parede </p></div></div><div class="top"><p class="src"><a id="v:nextCoordP" class="def">nextCoordP</a> :: <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> <a href="#v:nextCoordP" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dado uma coordenada e uma orienta&#231;&#227;o, assume que a orienta&#231;&#227;o permanecer&#225; a mesma pelas pr&#243;ximas 4 jogadas e determina a coordenada final</p></div></div><div class="top"><p class="src"><a id="v:absList" class="def">absList</a> :: [<a href="Types.html#t:Coords" title="Types">Coords</a>] -&gt; [<a href="Types.html#t:Coords" title="Types">Coords</a>] <a href="#v:absList" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que passa as coordenadas para seu valor absoluto</p></div></div><div class="top"><p class="src"><a id="v:square" class="def">square</a> :: <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; Float <a href="#v:square" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que calcula a dist&#226;ncia da coordenada &#224; origem</p></div></div><div class="top"><p class="src"><a id="v:index-39-" class="def">index'</a> :: Float -&gt; [Float] -&gt; Int <a href="#v:index-39-" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dado um n&#250;mero e uma lista, determina o &#237;ndice deste n&#250;mero na lista</p></div></div><div class="top"><p class="src"><a id="v:whichOrientation" class="def">whichOrientation</a> :: <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a> <a href="#v:whichOrientation" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que recebe a coordenada atual do fantasma e a que ele quer ir e devolve a orienta&#231;&#227;o necess&#225;ria para a pr&#243;xima jogada. Considera-se apenas que a coordenada desejada difere apenas de 1.</p></div></div><div class="top"><p class="src"><a id="v:betterRun" class="def">betterRun</a> :: [<a href="Types.html#t:Coords" title="Types">Coords</a>] -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> <a href="#v:betterRun" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que recebe a lista de coordenadas poss&#237;veis para o fantasma, a coordenada do pacman e devolve a coordenada melhor para o fantasma ir de forma que se encontre mais distante do pacman </p><pre>lc = map (coordDif (x,y)) ((a,b):bs)
</pre><ul><li>((a,b):bs) corresponde a lista das coordenadas poss&#237;veis que o fantasma pode ir;</li><li>(x,y) corresponde a coordenada que ele pretende estar mais distante;</li><li>Com isto, aplica-se a fun&#231;&#227;o <strong>coordDif</strong> a todas as coordenadas da lista, pela qual ir&#225; resultar na lista das diferen&#231;as entre cada coordenada e a coordenada (x,y);</li><li>Estas diferen&#231;as determinar&#227;o o n&#250;mero de jogadas necess&#225;rias para chegar na coordenada (x,y).</li></ul><pre>best = maximum $ map (square) $ absList lc
</pre><ul><li>Caso o fantasma precisasse ir para a esquerda ou para cima, ter&#237;amos tuplos com as jogadas necess&#225;rias nos quais os elementos seriam negativas. Portanto, para que o efeito de compara&#231;&#227;o da que cont&#233;m menos jogadas o poss&#237;vel seja v&#225;lido, optamos por utilizar o valor absoluto dos elementos desta lista;</li><li>Caso tiv&#233;ssemos [(0,3),(1,0)] e aplic&#225;ssemos o maximum, este resultaria em (1,0). Neste caso, n&#227;o seria v&#225;lido pois corresponde a 1 jogada enquanto (0,3) corresponde a 3 jogadas. Portanto, n&#227;o retornaria o tuplo com o maior n&#250;mero de jogadas poss&#237;vel;</li><li>Para resolver este problema, optamos por chamar a fun&#231;&#227;o <strong>square</strong> na qual calcula a dist&#226;ncia a origem da coordenada, agora, ao chamar o maximum, devolve o que era suposto;</li><li>Portanto, best corresponde ao tuplo que cont&#233;m o maior n&#250;mero de jogadas poss&#237;vel para chegar na coordenada desejada.</li></ul><pre>n2 = index' best (map (square) $ absList lc)
</pre><ul><li>Agora, precisamos saber qual coordenada das poss&#237;veis que o fantasma pode se locomover &#233; que este tuplo de jogadas corresponde;</li><li>Para isto, achamos o &#237;ndice do tuplo na lista de tuplos. </li></ul><pre>((a,b):bs) !! n2 
</pre><ul><li>Como a lista encontra-se na mesma ordem que as coordenadas poss&#237;veis do fantasma, conseguimos saber qual coordenada corresponde a este &#237;ndice;</li><li>Portanto, esta &#233; a coordenada que o fantasma deve escolher ir.</li></ul></div></div><div class="top"><p class="src"><a id="v:littleRunaway" class="def">littleRunaway</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; [<a href="Types.html#t:Corridor" title="Types">Corridor</a>] -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a> <a href="#v:littleRunaway" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que recebe o fantasma, as coordenadas do pacman no mapa, o labirinto e devolve a orienta&#231;&#227;o para a pr&#243;xima jogada do fantasma para que o fantasma se distancie do pacman</p><pre>lc = [(a+1,b),(a-1,b),(a,b+1),(a,b-1)]
</pre><ul><li>Estas s&#227;o as coordenadas para qual o fantasma tem a op&#231;&#227;o de se locomover</li></ul><pre>poss = notWall lc (x:xs)
</pre><ul><li>Representam as coordenadas que o fantasma pode ir nas quais n&#227;o h&#225; <strong>Wall</strong></li></ul><pre>theone = betterRun poss (c,d)
</pre><ul><li>&#201; aplicada a fun&#231;&#227;o <strong>betterRun</strong> que ir&#225; comparar as coordenadas poss&#237;veis para o fantasma com a coordenada recebida do Pacman (podendo ser a atual ou a prevista ap&#243;s 4 jogadas) e ir&#225; determinar a que o levar&#225; a estar mais distante do Pacman</li></ul><pre>whichOrientation (a,b) theone
</pre><ul><li>Esta fun&#231;&#227;o recebe a coordenada atual do fantasma e determina qual <strong>Orientation</strong> este deve escolher na Play para que se distancie do Pacman.</li></ul></div></div><div class="top"><p class="src"><a id="v:scatterMode" class="def">scatterMode</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; Int -&gt; <a href="Types.html#t:Play" title="Types">Play</a> <a href="#v:scatterMode" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que determina a melhor jogada caso o fantasma se encontre <strong>Dead</strong> com o objetivo de fugir do Pacman</p><pre>if (z,w) == (middleMaze (x:xs),middleWidth (x:xs)) then Move n U
</pre><ul><li>Caso a coordenada atual do fantasma corresponda ao centro da casa de fantasmas, ele ir&#225; movimentar-se para cima a fim de sair da casa de fantasmas.</li></ul><pre>ghost = findPlayer n (p:ps)
</pre><ul><li>Para selecionar o fantasma com id <strong>n</strong> da lista de jogadores</li></ul><pre>(z,w) = getPlayerCoords ghost
</pre><ul><li>Para obter a coordenada atual deste fantasma</li></ul><pre>coordp = getPlayerCoords $ getPacman (p:ps)
</pre><ul><li>Selecionamos o pacman e obtemos sua coordenada atual</li></ul><pre>pacOri = getPlayerOrientation $ getPacman (p:ps)
</pre><ul><li>Obtemos a orienta&#231;&#227;o atual do pacman</li></ul><pre>coordp2 = nextCoordP coordp pacOri 
</pre><ul><li>De acordo com a orienta&#231;&#227;o do pacman, obtemos a coordenada equivalente a 4 casas a frente;</li><li>Por exemplo, caso o pacman tenha coordenada (a,b) e esteja com orienta&#231;&#227;o R, teremos (a,b+4). &#201; uma forma de prever para onde o Pacman pretende seguir.</li></ul><h1>Decidimos dividir em duas estrat&#233;gias consuante o id do fantasma:</h1><h2><em>ID par</em></h2><h3>Caso o ID seja par, o fantasma ir&#225; optar pela <strong>Orientation</strong> pela qual sua p&#341;oxima jogada o levar&#225; para a coordenada mais distante da coordenada atual do Pacman</h3><pre>ori = littleRunaway ghost coordp (x:xs)
</pre><ul><li>&#201; aplicada a fun&#231;&#227;o <strong>littleRunaway</strong> que cont&#233;m estrat&#233;gia para que o fantasma fuja da coordenada atual do Pacman.</li></ul><h2><em>ID &#237;mpar</em></h2><h3>Caso o ID seja &#237;mpar, o fantasma tentar&#225; prever em qual coordenada o Pacman estar&#225; ap&#243;s quatro jogados e ir&#225; optar pela <strong>Orientation</strong> pela qual sua pr&#243;xima jogada o levar&#225; para a coordenada mais distante da coordenada do Pacman ap&#243;s quatro jogadas.</h3><pre>o = littleRunaway ghost coordp2 (x:xs)
</pre><ul><li>&#201; aplicada a fun&#231;&#227;o <strong>littleRunaway</strong> que cont&#233;m estrat&#233;gia para que o fantasma fuja da coordenada prevista do Pacman ap&#243;s quatro jogadas.</li></ul></div></div><div class="top"><p class="src"><a id="v:bestCoord" class="def">bestCoord</a> :: [<a href="Types.html#t:Coords" title="Types">Coords</a>] -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> <a href="#v:bestCoord" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que recebe a lista de coordenadas poss&#237;veis para o fantasma, a coordenada do pacman e devolve a coordenada melhor para o fantasma ir de forma que se encontre mais perto do pacman </p><pre>lc = map (coordDif (x,y)) ((a,b):bs)
</pre><ul><li>((a,b):bs) corresponde a lista das coordenadas poss&#237;veis que o fantasma pode ir;</li><li>(x,y) corresponde a coordenada que ele pretende estar mais pr&#243;ximo;</li><li>Com isto, aplica-se a fun&#231;&#227;o <strong>coordDif</strong> a todas as coordenadas da lista, pela qual ir&#225; resultar na lista das diferen&#231;as entre cada coordenada e a coordenada (x,y);</li><li>Estas diferen&#231;as determinar&#227;o o n&#250;mero de jogadas necess&#225;rias para chegar na coordenada (x,y).</li></ul><pre>best = minimum $ map (square) $ absList lc
</pre><ul><li>Caso o fantasma precisasse ir para a esquerda ou para cima, ter&#237;amos tuplos com as jogadas necess&#225;rias nos quais os elementos seriam negativas. Portanto, para que o efeito de compara&#231;&#227;o da que cont&#233;m menos jogadas o poss&#237;vel seja v&#225;lido, optamos por utilizar o valor absoluto dos elementos desta lista;</li><li>Caso tiv&#233;ssemos [(0,3),(1,0)] e aplic&#225;ssemos o <strong>minimum</strong>, este resultaria em (0,3). Neste caso, n&#227;o seria v&#225;lido pois corresponde a 3 jogadas enquanto (1,0) corresponde a 1 jogada. Portanto, n&#227;o retornaria o tuplo com o menor n&#250;mero de jogadas poss&#237;vel;</li><li>Para resolver este problema, optamos por chamar a fun&#231;&#227;o <strong>square</strong> na qual calcula a dist&#226;ncia a origem da coordenada, agora, ao chamar o minimum, devolve o que era suposto;</li><li>Portanto, best corresponde ao tuplo que cont&#233;m o menor n&#250;mero de jogadas poss&#237;vel para chegar na coordenada desejada.</li></ul><pre>n2 = index' best (map (square) $ absList lc)
</pre><ul><li>Agora, precisamos saber qual coordenada das poss&#237;veis que o fantasma pode se locomover &#233; que este tuplo de jogadas corresponde;</li><li>Para isto, achamos o &#237;ndice do tuplo na lista de tuplos. </li></ul><pre>((a,b):bs) !! n2 
</pre><ul><li>Como a lista encontra-se na mesma ordem que as coordenadas poss&#237;veis do fantasma, conseguimos saber qual coordenada corresponde a este &#237;ndice;</li><li>Portanto, esta &#233; a coordenada que o fantasma deve escolher ir.</li></ul></div></div><div class="top"><p class="src"><a id="v:goToPac" class="def">goToPac</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; [<a href="Types.html#t:Corridor" title="Types">Corridor</a>] -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a> <a href="#v:goToPac" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que recebe o fantasma, as coordenadas do pacman no mapa, o labirinto e devolve a orienta&#231;&#227;o para a pr&#243;xima jogada do fantasma para que o fantasma se aproxime do pacman</p><pre>lc = [(a+1,b),(a-1,b),(a,b+1),(a,b-1)]
</pre><ul><li>Estas s&#227;o as coordenadas para qual o fantasma tem a op&#231;&#227;o de se locomover</li></ul><pre>poss = notWall lc (x:xs)
</pre><ul><li>Representam as coordenadas que o fantasma pode ir nas quais n&#227;o h&#225; <strong>Wall</strong></li></ul><pre>theone = bestCoord poss (c,d)
</pre><ul><li>&#201; aplicada a fun&#231;&#227;o <strong>bestCoord</strong> que ir&#225; comparar as coordenadas poss&#237;veis para o fantasma com a coordenada do Pacman (podendo ser a atual ou a prevista ap&#243;s 4 jogadas) e ir&#225; determinar a que o levar&#225; a estar mais pr&#243;ximo do Pacman</li></ul><pre>whichOrientation (a,b) theone
</pre><ul><li>Esta fun&#231;&#227;o recebe a coordenada atual do fantasma e determina qual <strong>Orientation</strong> este deve escolher na Play para que se aproxime do Pacman.</li></ul></div></div><div class="top"><p class="src"><a id="v:chaseMode" class="def">chaseMode</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; Int -&gt; <a href="Types.html#t:Play" title="Types">Play</a> <a href="#v:chaseMode" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que determina a melhor jogada caso o fantasma se encontre <strong>Alive</strong> com o objetivo de perseguir o Pacman</p><pre>if (z,w) == (middleMaze (x:xs),middleWidth (x:xs)) then Move n U
</pre><ul><li>Caso a coordenada atual do fantasma corresponda ao centro da casa de fantasmas, ele ir&#225; movimentar-se para cima a fim de sair da casa de fantasmas.</li></ul><pre>ghost = findPlayer n (p:ps)
</pre><ul><li>Para selecionar o fantasma com id <strong>n</strong> da lista de jogadores</li></ul><pre>(z,w) = getPlayerCoords ghost
</pre><ul><li>Para obter a coordenada atual deste fantasma</li></ul><pre>coordp = getPlayerCoords $ getPacman (p:ps)
</pre><ul><li>Selecionamos o pacman e obtemos sua coordenada atual</li></ul><pre>pacOri = getPlayerOrientation $ getPacman (p:ps)
</pre><ul><li>Obtemos a orienta&#231;&#227;o atual do pacman</li></ul><pre>coordp2 = nextCoordP coordp pacOri 
</pre><ul><li>De acordo com a orienta&#231;&#227;o do pacman, obtemos a coordenada equivalente a 4 casas a frente;</li><li>Por exemplo, caso o pacman tenha coordenada (a,b) e esteja com orienta&#231;&#227;o R, teremos (a,b+4). &#201; uma forma de prever para onde o Pacman pretende seguir.</li></ul><h1>Decidimos dividir em duas estrat&#233;gias consuante o id do fantasma:</h1><h2><em>ID par</em></h2><h3>Caso o ID seja par, o fantasma ir&#225; optar pela <strong>Orientation</strong> pela qual sua p&#341;oxima jogada o levar&#225; para a coordenada mais pr&#243;xima da coordenada atual do Pacman</h3><pre>ori = goToPac ghost coordp (x:xs)
</pre><ul><li>&#201; aplicada a fun&#231;&#227;o <strong>goToPac</strong> que cont&#233;m estrat&#233;gia para que o fantasma v&#225; para a coordenada atual do Pacman.</li></ul><h2><em>ID &#237;mpar</em></h2><h3>Caso o ID seja &#237;mpar, o fantasma tentar&#225; prever em qual coordenada o Pacman estar&#225; ap&#243;s quatro jogados e ir&#225; optar pela <strong>Orientation</strong> pela qual sua pr&#243;xima jogada o levar&#225; para a coordenada mais pr&#243;xima da coordenada do Pacman ap&#243;s quatro jogadas.</h3><pre>o = goToPac ghost coordp2 (x:xs)
</pre><ul><li>&#201; aplicada a fun&#231;&#227;o <strong>goToPac</strong> que cont&#233;m estrat&#233;gia para que o fantasma siga para a coordenada prevista do Pacman ap&#243;s quatro jogadas.</li></ul></div></div><div class="top"><p class="src"><a id="v:runOrChase" class="def">runOrChase</a> :: [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; [<a href="Types.html#t:Play" title="Types">Play</a>] <a href="#v:runOrChase" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dado uma lista de fantasmas e o estado atual do jogo, devolve a lista de jogadas com a melhor estrat&#233;gia</p><pre>|ghostMode == Alive = chaseMode st id : runOrChase gs st
</pre><ul><li>Caso o primeiro fantasma da lista seja <strong>Alive</strong>, a fun&#231;&#227;o <strong>chaseMode</strong> &#233; chamada para este fantasma de modo com que persiga o pacman. E <strong>runOrChase</strong> &#233; chamada recursivamente para os restantes fantasmas.</li></ul><pre>|otherwise = scatterMode st id : runOrChase gs st      
</pre><ul><li>Caso o primeiro fantasma da lista seja <strong>Dead</strong>, a fun&#231;&#227;o <strong>scatterMode</strong> &#233; chamada para este fantasma de modo com que fuja do pacman. E <strong>runOrChase</strong> &#233; chamada recursivamente para os restantes fantasmas.</li></ul></div></div><div class="top"><p class="src"><a id="v:ghostPlay" class="def">ghostPlay</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; [<a href="Types.html#t:Play" title="Types">Play</a>] <a href="#v:ghostPlay" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dado o estado atual do jogo, devolve a lista de jogadas com a melhor estrat&#233;gia para os fantasmas</p><pre>runOrChase (g:gs) st
</pre><ul><li>Aplica-se a fun&#231;&#227;o auxiliar <strong>runOrChase</strong> a lista de jogadores fantasmas. Esta fun&#231;&#227;o &#233; explicada mais a frente e &#233; respons&#225;vel pelos fantasmas optarem pela melhor estrat&#233;gia caso seu estado seja <strong>Alive</strong> ou <strong>Dead</strong>.</li></ul></div></div><div class="top"><p class="src"><a id="v:ghostPlay2" class="def">ghostPlay2</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; [<a href="Types.html#t:Play" title="Types">Play</a>] <a href="#v:ghostPlay2" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dado o estado atual do jogo, devolve a lista de jogadas com a melhor estrat&#233;gia para os fantasmas que encontram-se <strong>Alive</strong></p><h3>Foi necess&#225;rio criar esta fun&#231;&#227;o que ser aplicada na Tarefa 4, na qual quando o step n&#227;o &#233; m&#250;ltiplo de 2, apenas os fantasmas sem a velocidade reduzida efetuam jogadas</h3><pre>where (g:gs) = getGhosts' $ getGhosts (p:ps)
</pre><ul><li>Primeiro selecionamos os fantasmas da lista de jogadores e, a seguir, selecionamos apenas os fantasmas <strong>Alive</strong></li></ul><h3>De resto, a fun&#231;&#227;o comporta-se da mesma maneira que a <strong>ghostPlay</strong> </h3></div></div><div class="top"><p class="src"><a id="v:getGhosts-39-" class="def">getGhosts'</a> :: [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] <a href="#v:getGhosts-39-" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que dado uma lista de fantasmas, retorna apenas a lista com os fantasmas que encontram-se <strong>Alive</strong></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>